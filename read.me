接口列表：
1、登录接口
   url:   /login
   params: {owner_nickName: '', password: ''}
   method: POST
   response: {data:null,msg:'登录成功'}
   error: {data:null,msg:'帐号或用户错误'}

2、获取当前用户
   url:   /currentowner
   params: 无
   method: GET
   角色按照美元符号进行组合!
{"data":[{"ownerid":2,"owner_nickName":"xiaofan","owner_realName":"owner_realName","role":"admin$test$fuwu"}],"message":"获取成功"}

3、用户退出
   url: /logout
   params: 无
   method: GET,
   response: {data:null,msg:'退出成功'}

   备注:  owner 的表结构如下:
   create table `owner` (
     `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
     `owner_nickName` TEXT NOT NULL,
     `owner_realName` TEXT NOT NULL,
     `password` TEXT NOT NULL,
     `mobile` BIGINT NOT NULL,
     `email` TEXT NOT NULL,
     `memo` TEXT NOT NULL,
     `status` Boolean NOT NULL,
     `time` Datetime NOT NULL
   )


==========================================================================

4、报告列表（用户名自己session里面取）, 如果未登录,则返回的数据是null
   url：  /report/list
   params: {pageNo: 1, pageSize: 20}     //   已经成功的咯! pageNo=2&pageSize=2
   method: GET,
   response:
   {
      data:[{
          "id": 23,
          "owner": "",
          "reportName": "小凡的报告",
          "execute_type": "execute_type",
          "once2circle_last_executed_time": 1472701943000,
          "modify_time": 1472701943000,
          "reportUrl": "reportUrl"
      },{
        ...
      }],
      page:{
        currentPageNo: 1,
        pageSize: 20,  // 传的参数
        totalCount: 65,  // 数据总条数
        totalPageCount: 4  // 页数
      }
      msg: '请求成功'
    }


5、保存报告
    url:   /report/add
    params: {reportName: '',  reportContent:''}    //  增加了一个字段 reportName
    method: POST
    response: {data:null,msg:'保存成功'}

     关于用户名称为空时,目前也是能顾保存的!!!!!!  后续待优化!


6、预览报告
    url:   /preview
    params: {reportContent:''}
    method: POST
    response: {data:null,msg:'预览成功'}



7 创建用户
    url:   /addowner
    params: {"owner_nickName": "", "owner_realName": "", "password": "", "mobile":"", "email":""}
    method: post
    response: {data:{owner_nickName: owner_nickName},msg:'用户创建成功'}
    error: {data: null, message: '用户名重复(错误信息)'}

8 已有用户列表
    url:  /listowner
    params: {}
    response: {
      data: [{
         `id`: 131232,
         `owner_nickName`: "",
         `owner_realName`:  "",
         `mobile`: "",
         `email`: "fasfdasdf@163.com",
         `memo`: "",
         `status`:"",
         `time`: ""
      },{

      }],
      message: '获取成功'
    }

http://localhost:9000/currentowner
{"data":[{"ownerid":2,"owner_nickName":"xiaofan","owner_realName":"owner_realName","role":"admin$test$fuwu"}],"message":"获取成功"}



    待完善的接口
    ====
    更新报告reportContent接口
    设定报告更新类型接口(将来一次性运行,还是将来间隔固定时间循环更新运行)


    管理员创建用户接口
    用户修改密码接口
    用户权限和角色的接口暂时不用考虑把!

    最后,关于报告中可能存在修改更新中,为了保证数据的运行时间的一致性,需要通过任务调度的状态,并且保存运行之后的相应结果
    应该可以通过一张报告任务调度表解决!!!

tasklist
========
taskid
report_id
owner_nickName
reportContent
reportUrl
scheduled_time
executed_start_time
executed_finish_time



任务调度——周期性的定时(固定时间)
新增和变动的情况——无解?  状态的判断!!!


任务调度的三级控制流程:
1. 定时的生成与更新即将发生的一段时间内的任务列表——五分钟,或者十分钟一次的动态的更新,插入,以及删除相应的任务列表
2. 定时的获取即将发生的任务列表,且判断是否需要构造调度队列——获取当前时间的一个小时以内的任务,以及已经过去却由于任务挤压导致未执行的任务作为本次批量执行的任务列表(故,需要增加任务执行状态的字段!)
3. 通过以上构造的调度队列,生成一次性的执行任务——且该任务生成之后,直接不用理会取消的问题!!! 由于以上已经是按照小时为单位考虑到了任务的更新和取消问题,故直接按照一次性任务直接执行即可!
备注: 关于 schedule actor 的取消的模型!!!
多任务执行  VS  单任务执行队列!!!(从稳定性的角度上来说,选择单任务的执行队列!!!)
http://doc.akka.io/docs/akka/snapshot/scala/scheduler.html


report =>  tasklist  =>  execution


(execute_type, once_scheduled_execute_time, circle_execute_start_time,circle_execute_interval_seconds)
match
case once =>  if( once_scheduled_execute_time - NOW > 3600 seconds)  the_next_execute_time = once_scheduled_execute_time
case circle => the_next_execute_time = circle_execute_start_time + {( NOW - circle_execute_start_time ) / circle_execute_interval_seconds} ROUNDUP * circle_execute_interval_seconds

report  the_next_execute_time

inser/update  tasklist!!!


From tasklist to schedule List
for (i <- takslist) schedule(tasklist.i 相关的属性列表——可以放时间,也可以不放时间则为一次性的执行列表)
执行即可!!!!!!


调整 report 表结构
生成 testcontroller 的相关方法
